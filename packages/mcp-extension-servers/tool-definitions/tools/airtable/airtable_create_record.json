{
  "id": "airtable-create-record",
  "name": "airtable_create_record",
  "description": "Create a new record in an Airtable table. Clicks the add row button and fills in field values by clicking cells and typing.",
  "version": "1.0.0",
  "parameters": [
    {
      "name": "table_url",
      "type": "string",
      "description": "Airtable table URL (e.g. 'https://airtable.com/appXXX/tblXXX/viwXXX')",
      "required": true
    },
    {
      "name": "field_values",
      "type": "string",
      "description": "JSON string of field:value pairs (e.g. '{\"Name\":\"Acme Corp\",\"Status\":\"Active\",\"Notes\":\"New client\"}')",
      "required": true
    }
  ],
  "steps": [
    {
      "action": "navigate",
      "url": "{{table_url}}",
      "label": "Open Airtable table"
    },
    {
      "action": "waitForSelector",
      "selector": ".dataRow, [data-rowindex], .headerRow",
      "timeout": 15000,
      "label": "Wait for grid to load"
    },
    {
      "action": "wait",
      "ms": 2000,
      "label": "Let grid fully render"
    },
    {
      "action": "click",
      "selector": ".addRowButton, [aria-label=\"Add row\"], [data-testid=\"add-row-button\"], .newRowButton",
      "label": "Click add row button"
    },
    {
      "action": "wait",
      "ms": 1500,
      "label": "Wait for new row to appear"
    },
    {
      "action": "code",
      "code": "const fields = JSON.parse(`{{field_values}}`); const headers = []; document.querySelectorAll('.headerRow .header, .columnHeader, [data-columnid] .header, [role=\"columnheader\"]').forEach(h => { headers.push(h.textContent?.trim() || ''); }); const lastRow = document.querySelector('.dataRow:last-child, [data-rowindex]:last-child, [role=\"row\"]:last-child'); if (!lastRow) throw new Error('Could not find newly created row'); const filledFields = []; for (const [fieldName, value] of Object.entries(fields)) { const colIndex = headers.findIndex(h => h.toLowerCase() === fieldName.toLowerCase()); if (colIndex === -1) { filledFields.push({ field: fieldName, status: 'column_not_found' }); continue; } const cells = lastRow.querySelectorAll('.cell, [data-columnid], [role=\"gridcell\"]'); const targetCell = cells[colIndex]; if (!targetCell) { filledFields.push({ field: fieldName, status: 'cell_not_found' }); continue; } targetCell.click(); await new Promise(r => setTimeout(r, 500)); const input = targetCell.querySelector('.cellInput, [contenteditable=\"true\"], input, textarea') || document.activeElement; if (input) { if (input.contentEditable === 'true') { input.textContent = String(value); input.dispatchEvent(new Event('input', { bubbles: true })); } else { const nativeSet = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, 'value').set || Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, 'value').set; nativeSet.call(input, String(value)); input.dispatchEvent(new Event('input', { bubbles: true })); input.dispatchEvent(new Event('change', { bubbles: true })); } filledFields.push({ field: fieldName, status: 'filled', value: String(value) }); } else { filledFields.push({ field: fieldName, status: 'no_input_found' }); } await new Promise(r => setTimeout(r, 300)); } document.activeElement?.blur(); return { success: true, fields_processed: filledFields.length, fields: filledFields }",
      "name": "result",
      "label": "Fill in field values for new record"
    }
  ]
}